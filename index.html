<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Bot in Browser</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #log { margin-top: 20px; border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: scroll; }
    </style>
</head>
<body>
    <h1>Wait...</h1>
    <div></div>

    <script>
        const TOKEN = '7778832162:AAHrNgdS-b-PqqfDPWIVmFzipZJBn1Fs4oY';
        let offset = 0;
        let polling = false;

        // === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ ===
        const waiting_users = new Set();
        const active_chats = {};
        const private_nick_for_user = {};
        const private_users_by_nick = {};
        const private_display_message = {};
        const awaiting_nick = new Set();
        const save_history_for_user = {};
        const chat_history = {};
        const searching_users = new Set();

        // === –¢–µ–∫—Å—Ç—ã –∏ –∫–Ω–æ–ø–∫–∏ ===
        const BUTTON_STOP_SEARCH = "‚ùå –ü—Ä–µ–∫—Ä–∞—Ç–∏—Ç—å –ø–æ–∏—Å–∫";
        const MAIN_MENU_TEXT = "üëã –ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –∞–Ω–æ–Ω–∏–º–Ω—ã–π —á–∞—Ç.\n\n–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –Ω–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ –∏ –Ω–æ–≤—ã–µ –∑–Ω–∞–∫–æ–º—Å—Ç–≤–∞ ‚Äî –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:";
        const BUTTON_SEARCH = "üîç –ò—Å–∫–∞—Ç—å —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞";
        const BUTTON_HISTORY = "üìú –ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–æ–≤";
        const BUTTON_DEL_HISTORY = "üóë –£–¥–∞–ª–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —á–∞—Ç–æ–≤";
        const BUTTON_TOGGLE_HISTORY_OFF = "‚õî –ù–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –∏—Å—Ç–æ—Ä–∏—é";
        const BUTTON_TOGGLE_HISTORY_ON = "‚úÖ –í–∫–ª—é—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é";

        function now_ts() {
            return new Date().toISOString().slice(0, 19).replace('T', ' ') + ' UTC';
        }

        function main_menu_markup(user_id) {
            const save_hist = save_history_for_user[user_id] !== undefined ? save_history_for_user[user_id] : true;
            const kb = { inline_keyboard: [] };

            if (searching_users.has(user_id)) {
                kb.inline_keyboard.push([{ text: BUTTON_STOP_SEARCH, callback_data: "stop_search" }]);
            } else {
                kb.inline_keyboard.push([{ text: BUTTON_SEARCH, callback_data: "search" }]);
            }

            if (save_hist) {
                kb.inline_keyboard.push([
                    { text: BUTTON_HISTORY, callback_data: "view_history" },
                    { text: BUTTON_DEL_HISTORY, callback_data: "del_history" }
                ]);
                kb.inline_keyboard.push([{ text: BUTTON_TOGGLE_HISTORY_OFF, callback_data: "toggle_history" }]);
            } else {
                kb.inline_keyboard.push([{ text: BUTTON_TOGGLE_HISTORY_ON, callback_data: "toggle_history" }]);
            }
            return kb;
        }

        function summarize_message(msg) {
            if (msg.text) {
                let text = msg.text;
                if (text.length > 80) {
                    text = text.slice(0, 77) + "...";
                }
                return `Text: ${text}`;
            }
            if (msg.photo) {
                return "Photo";
            }
            if (msg.video) {
                return "Video";
            }
            if (msg.audio) {
                return "Audio";
            }
            if (msg.document) {
                return `Document: ${msg.document.file_name || 'file'}`;
            }
            if (msg.voice) {
                return "Voice";
            }
            return "Message";
        }

        function save_message_history(user_id, partner_id, direction, summary) {
            if (!save_history_for_user[user_id]) {
                return;
            }
            const entry = {
                time: now_ts(),
                with: partner_id,
                dir: direction,
                summary: summary,
            };
            if (!chat_history[user_id]) {
                chat_history[user_id] = [];
            }
            chat_history[user_id].push(entry);
        }

        function startBot() {
            if (polling) {
                log('Bot is already running.');
                return;
            }
            polling = true;
            poll();
        }

        async function poll() {
            if (!polling) return;
            try {
                const response = await fetch(`https://api.telegram.org/bot${TOKEN}/getUpdates?offset=${offset}&timeout=30`);
                const data = await response.json();
                if (data.ok) {
                    for (const update of data.result) {
                        await processUpdate(update);
                        offset = update.update_id + 1;
                    }
                } else {
                    log('Error from API: ' + data.description);
                }
                poll(); // Continue polling
            } catch (error) {
                log('Polling error: ' + error.message);
                setTimeout(poll, 5000); // Retry after 5 seconds
            }
        }

        async function processUpdate(update) {
            if (update.message) {
                const message = update.message;
                const user_id = message.from.id;
                const chat_id = message.chat.id;

                if (awaiting_nick.has(user_id)) {
                    const nickname = message.text.trim();
                    register_private_nick(user_id, nickname);
                    awaiting_nick.delete(user_id);
                    return;
                }

                if (message.text && message.text.startsWith('/')) {
                    const command = message.text.slice(1).toLowerCase();
                    if (command === 'start') {
                        await sendMessage(chat_id, MAIN_MENU_TEXT, { reply_markup: main_menu_markup(user_id) });
                    } else if (command === 'stop') {
                        stop_chat(user_id, chat_id, message.message_id);
                    } else if (command === 'next') {
                        next_chat(user_id, chat_id, message.message_id);
                    }
                    return;
                }

                const partner_id = active_chats[user_id];
                if (!partner_id) {
                    await sendMessage(chat_id, "‚ö† –í—ã –Ω–µ –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ. –ù–∞–∂–º–∏—Ç–µ /start –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é.");
                    return;
                }

                const summary = summarize_message(message);
                try {
                    await copyMessage(partner_id, chat_id, message.message_id);
                    save_message_history(user_id, partner_id, "out", summary);
                    save_message_history(partner_id, user_id, "in", summary);
                } catch (e) {
                    log('Failed to copy message: ' + e.message);
                    await sendMessage(chat_id, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
                }
            } else if (update.callback_query) {
                const call = update.callback_query;
                const user_id = call.from.id;
                const message_id = call.message.message_id;
                const chat_id = call.message.chat.id;
                const data = call.data;

                if (data === "search") {
                    start_search_for_user(user_id, chat_id, message_id);
                } else if (data === "stop_search") {
                    stop_search_for_user(user_id, chat_id, message_id);
                } else if (data === "view_history") {
                    show_history(user_id, chat_id, message_id);
                } else if (data === "del_history") {
                    delete chat_history[user_id];
                    await editMessageText(chat_id, message_id, "–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–æ–≤ —É–¥–∞–ª–µ–Ω–∞.", { reply_markup: main_menu_markup(user_id) });
                } else if (data === "toggle_history") {
                    let cur = save_history_for_user[user_id] !== undefined ? save_history_for_user[user_id] : true;
                    cur = !cur;
                    save_history_for_user[user_id] = cur;
                    if (cur) {
                        await editMessageText(chat_id, message_id, "–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –≤–∫–ª—é—á–µ–Ω–æ.", { reply_markup: main_menu_markup(user_id) });
                    } else {
                        delete chat_history[user_id];
                        await editMessageText(chat_id, message_id, "–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –æ—Ç–∫–ª—é—á–µ–Ω–æ.", { reply_markup: main_menu_markup(user_id) });
                    }
                }

                // Answer callback query to remove loading indicator
                await answerCallbackQuery(call.id);
            }
        }

        function stop_search_for_user(user_id, chat_id, message_id) {
            waiting_users.delete(user_id);
            searching_users.delete(user_id);
            const text = "‚ùå –ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.";
            editMessageText(chat_id, message_id, text, { reply_markup: main_menu_markup(user_id) });
        }

        function start_search_for_user(user_id, chat_id, message_id) {
            if (active_chats[user_id]) {
                editMessageText(chat_id, message_id, "‚ö† –í—ã —É–∂–µ –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ.", { reply_markup: main_menu_markup(user_id) });
                return;
            }
            if (!waiting_users.has(user_id)) {
                waiting_users.add(user_id);
                searching_users.add(user_id);
                editMessageText(chat_id, message_id, "‚è≥ –ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...", { reply_markup: main_menu_markup(user_id) });
            }
            if (waiting_users.size >= 2) {
                waiting_users.delete(user_id);
                const waitingArray = Array.from(waiting_users);
                const partner_id = waitingArray[Math.floor(Math.random() * waitingArray.length)];
                waiting_users.delete(partner_id);
                searching_users.delete(user_id);
                searching_users.delete(partner_id);

                active_chats[user_id] = partner_id;
                active_chats[partner_id] = user_id;

                const notifyText = "‚úÖ –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω!\n–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n\n–ß—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å ‚Äî /stop\n–ß—Ç–æ–±—ã —Å–ª–µ–¥—É—é—â–∏–π ‚Äî /next";
                for (const uid of [user_id, partner_id]) {
                    try {
                        sendMessage(uid, notifyText, { reply_markup: main_menu_markup(uid) });
                    } catch (e) {
                        log(`Failed to notify user ${uid} when pairing: ${e.message}`);
                    }
                }
            }
        }

        function stop_chat(user_id, chat_id, message_id) {
            if (active_chats[user_id]) {
                const partner_id = active_chats[user_id];
                delete active_chats[user_id];
                if (active_chats[partner_id] === user_id) {
                    delete active_chats[partner_id];
                    sendMessage(partner_id, "‚ùå –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç.");
                    sendMessage(partner_id, "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", { reply_markup: main_menu_markup(partner_id) });
                }
                sendMessage(chat_id, "‚ùå –ß–∞—Ç –∑–∞–≤–µ—Ä—à—ë–Ω.", { reply_markup: main_menu_markup(user_id) });
            } else {
                sendMessage(chat_id, "‚ö† –í—ã –Ω–µ –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ.");
            }
        }

        function next_chat(user_id, chat_id, message_id) {
            if (active_chats[user_id]) {
                const partner_id = active_chats[user_id];
                delete active_chats[user_id];
                if (active_chats[partner_id] === user_id) {
                    delete active_chats[partner_id];
                    waiting_users.add(partner_id);
                    searching_users.add(partner_id);
                    sendMessage(partner_id, "‚ùå –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç. –í—ã –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –≤ –æ—á–µ—Ä–µ–¥—å –ø–æ–∏—Å–∫–∞.", { reply_markup: main_menu_markup(partner_id) });
                }
            }
            start_search_for_user(user_id, chat_id, message_id);
        }

        function show_history(user_id, chat_id, message_id) {
            const entries = chat_history[user_id] || [];
            let text;
            if (entries.length === 0) {
                text = "–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–æ–≤ –ø—É—Å—Ç–∞.";
            } else {
                const lines = entries.slice(-30).map(e => `[${e.time}] ${e.dir} with ${e.with}: ${e.summary}`);
                text = "–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è:\n\n" + lines.join("\n");
            }
            editMessageText(chat_id, message_id, text, { reply_markup: main_menu_markup(user_id) });
        }

        function register_private_nick(user_id, nickname) {
            const old = private_nick_for_user[user_id];
            if (old && old !== nickname) {
                if (private_users_by_nick[old]) {
                    private_users_by_nick[old].delete(user_id);
                }
            }
            private_nick_for_user[user_id] = nickname;
            if (!private_users_by_nick[nickname]) {
                private_users_by_nick[nickname] = new Set();
            }
            private_users_by_nick[nickname].add(user_id);
            sendMessage(user_id, `‚úÖ –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ –ø—Ä–∏–≤–∞—Ç-—Ä–µ–∂–∏–º–µ –∫–∞–∫: ${nickname}`);
        }

        async function sendMessage(chatId, text, options = {}) {
            let url = `https://api.telegram.org/bot${TOKEN}/sendMessage?chat_id=${chatId}&text=${encodeURIComponent(text)}`;
            if (options.reply_markup) {
                url += `&reply_markup=${encodeURIComponent(JSON.stringify(options.reply_markup))}`;
            }
            const response = await fetch(url);
            const data = await response.json();
            if (!data.ok) {
                log('Send error: ' + data.description);
            }
            return data;
        }

        async function editMessageText(chatId, messageId, text, options = {}) {
            let url = `https://api.telegram.org/bot${TOKEN}/editMessageText?chat_id=${chatId}&message_id=${messageId}&text=${encodeURIComponent(text)}`;
            if (options.reply_markup) {
                url += `&reply_markup=${encodeURIComponent(JSON.stringify(options.reply_markup))}`;
            }
            const response = await fetch(url);
            const data = await response.json();
            if (!data.ok) {
                log('Edit error: ' + data.description);
            }
            return data;
        }

        async function copyMessage(toChatId, fromChatId, messageId) {
            const url = `https://api.telegram.org/bot${TOKEN}/copyMessage?chat_id=${toChatId}&from_chat_id=${fromChatId}&message_id=${messageId}`;
            const response = await fetch(url);
            const data = await response.json();
            if (!data.ok) {
                throw new Error(data.description);
            }
            return data;
        }

        async function answerCallbackQuery(callbackQueryId) {
            const url = `https://api.telegram.org/bot${TOKEN}/answerCallbackQuery?callback_query_id=${callbackQueryId}`;
            const response = await fetch(url);
            const data = await response.json();
            if (!data.ok) {
                log('Answer callback error: ' + data.description);
            }
        }

        function log(message) {
            console.log(message);
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += `<p>${new Date().toLocaleTimeString()} - ${message}</p>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Start the bot immediately on page load
        window.addEventListener('load', startBot);
    </script>
</body>
</html>